Feature Ideas
-------------
* Doc: alt statement with optional integer weights
* Doc: else on for loops for empty lists [for str @s in LIST say [BLAH] else [BLUH] endfor]
* Doc: ``for'' for matrices?
* Doc: for: explicit integer index key (from 1)? [for str @s in LIST index @i say [BLAH] endfor]
* Doc: for: "sepby" for stuff between items
* Format: awk
* Format: gnu recutils
* Format: JSON
* Format: RFC822
* General: ability to see random seed and set seed at CL
* General: implicit "control fields" for record number etc.
* General: make special chars []#@ redefinable
* General: namespacing (qualified import?)
* General: optional default values for keys: e.g. Either(@foo, bar)
* General: prompt statement (maybe? could be fun)
* General: read preferences from a config file (.feivel?)
* General: stack trace on error
* General: special keys which update after every lookup? e.g. a variable which autoincrements
* Integer: hex, binary, octal constants
* Integer: bezout
* List: derange
* List: map, fold
* List: Shuffle list by permutation
* Matrix: determinant
* Matrix: insert row/column
* Matrix: shuffle entries
* Matrix: submatrix by row/col indices
* Matrix: Smith normal form (uses bezout)
* Matrix: Shuffle rows/cols by permutation
* Matrix: Build permutation matrix
* Polynomial: degree, division algorithm, gcd, bezout
* Permutation: Choose random permutation (of Sn? of a list?)
* Permutation: Orbits {{t}}
* Permutation: Shape {int}
* Rational: more Cauchy sequences (pi, e, trig functions)
* String: escaped unicode characters
* String: strformat (latex/html/ascii) -- in progress
* String: words/lines/splitat
* Tests: Golden tests for rational, boolean polynomials
* Type: cyclotomic numbers
* Type: tuples? (constructor)
* Type: trees (constructor)
* Arch: Groupoid class
* Arch: type synonyms
* Refactor: Typed and Get know too much about EvalM
  1: (done) move type information to AST
  2: (done) Implementation of typeOf becomes trivial; take out of EvalM
  3: (done) Rearrange order of args in lift1 and lift2 (lifted function should come last.)
  4: (done) Parser no longer needs to return explicit type info, so don't
  5: (started) use of typeOf in Eval is now more complicated than necessary. Fix it.
  6: Rename Typed class to HasType
  7: Take Get out of EvalM; separate get and getVal
  8: Clean up parsers (Fun and FunT are now the same?)
  9: data Typed t = t :# Type (maybe. how to handle function types)
* Refactor: Eval has lots of repetitive code
  1: (done) Make inject have type a -> Expr, and use getVal in liftN
  2: Separate put and putVal
  3: use RankNTypes to make dispatch helper functions
* Refactor: Eval is too big
  1: (done) Replace different expression types in grammar with just Expr
  2: (done) Parameterize IntExpr et. al.; e.g. IntExprLeaf a = blah & IntExpr a = AtLocus (IntExprLeaf a)
  3: (done) Move grammar types to own modules; e.g. Expr = IntE (IntExpr Expr)
  4: Clean up AST modules
  5: Move parsers to own modules
  6: Split parameters on grammar types with class constraints, e.g. IntExprType t => blah
       (recover type safety with modularity)
  7: (started) Move eval instances to own modules (will cause orphan instances)
