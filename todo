Feature Ideas
-------------
* Doc: alt statement with optional integer weights
* Doc: else on for loops for empty lists [for str @s in LIST say [BLAH] else [BLUH] endfor]
* Doc: ``for'' for matrices?
* Doc: for: explicit integer index key (from 1)? [for str @s in LIST index @i say [BLAH] endfor]
* Doc: for: "sepby" for stuff between items
* Format: awk
* Format: gnu recutils
* Format: JSON
* Format: RFC822
* General: ability to see random seed and set seed at CL
* General: implicit "control fields" for record number etc.
* General: make special chars []#@ redefinable
* General: namespacing (qualified import?)
* General: optional default values for keys: e.g. Either(@foo, bar)
* General: prompt statement (maybe? could be fun)
* General: read preferences from a config file (.feivel?)
* General: stack trace on error
* General: special keys which update after every lookup? e.g. a variable which autoincrements
* Integer: hex, binary, octal constants
* Integer: bezout
* List: derange, map, fold
* List: Shuffle list by permutation
* Matrix: determinant
* Matrix: insert row/column
* Matrix: shuffle entries
* Matrix: submatrix by row/col indices
* Matrix: Smith normal form (uses bezout)
* Matrix: Shuffle rows/cols by permutation
* Matrix: Build permutation matrix
* Polynomial: gcd, bezout
* Permutation: Choose random permutation (of Sn? of a list?)
* Permutation: Orbits {{t}}
* Permutation: Shape {int}
* Rational: more Cauchy sequences (pi, e, trig functions)
* String: escaped unicode characters
* String: strformat (latex/html/ascii) -- in progress
* String: words/lines/splitat
* Tests: Golden tests for boolean polynomials
* Type: cyclotomic numbers
* Type: tuples? (constructor)
* Type: trees (constructor)
* Type: Quadratic numbers
* Type: Dihedral words
* Arch: type synonyms
* Lib/Write: LaTeX (display option), Unicode instances. Use Unicode instead of Show.
* Refactor: General
  1: Move Error up the hierarchy of dependencies
  3: Rename Typed class to HasType
  7: use RankNTypes to make dispatch helper functions
  8: In Bool grammar, put type argument on LEq, GEq, etc. and refactor eval
* CL option: --type blah (default is doc) to specify parser
* pure :: a -> Bool (randomness or side-effect free)
* verifyType :: a -> Either SomeErr Bool?
