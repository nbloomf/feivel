Feature Ideas
-------------
* Doc: alt statement with optional integer weights
* Doc: else on for loops for empty lists [for str @s in LIST say [BLAH] else [BLUH] endfor]
* Doc: ``for'' for matrices?
* Doc: for: explicit integer index key (from 1)? [for str @s in LIST index @i say [BLAH] endfor]
* Doc: for: "sepby" for stuff between items
* Format: awk
* Format: gnu recutils
* Format: JSON
* Format: RFC822
* General: ability to see random seed and set seed at CL
* General: implicit "control fields" for record number etc.
* General: make special chars []#@ redefinable
* General: namespacing (qualified import?)
* General: optional default values for keys: e.g. Either(@foo, bar)
* General: prompt statement (maybe? could be fun)
* General: read preferences from a config file (.feivel?)
* General: stack trace on error
* General: special keys which update after every lookup? e.g. a variable which autoincrements
* Integer: hex, binary, octal constants
* Integer: bezout
* List: derange
* List: map, fold
* List: Shuffle list by permutation
* Matrix: determinant
* Matrix: insert row/column
* Matrix: shuffle entries
* Matrix: submatrix by row/col indices
* Matrix: Smith normal form (uses bezout)
* Matrix: Shuffle rows/cols by permutation
* Matrix: Build permutation matrix
* Polynomial: degree, division algorithm, gcd, bezout
* Permutation: Choose random permutation (of Sn? of a list?)
* Permutation: Orbits {{t}}
* Permutation: Shape {int}
* Rational: more Cauchy sequences (pi, e, trig functions)
* String: escaped unicode characters
* String: strformat (latex/html/ascii) -- in progress
* String: words/lines/splitat
* Tests: Golden tests for rational, boolean polynomials
* Type: cyclotomic numbers
* Type: tuples? (constructor)
* Type: trees (constructor)
* Arch: Groupoid class
* Arch: type synonyms
* Refactor: Typed and Get know too much about EvalM
  3: Rename Expr subfolder to Grammar
  4: Move Error up the hierarchy of dependencies
  5: (started) use of typeOf in Eval is now more complicated than necessary. Fix it.
  6: Rename Typed class to HasType
  8: (started) Clean up parsers (Fun and FunT are now the same?)
  9: data Typed t = t :# Type (maybe. how to handle function types)
* Refactor: Eval has lots of repetitive code
  2: Separate put and putVal
  3: use RankNTypes to make dispatch helper functions
* Refactor: Eval is too big
  5: (done) Move parsers to own modules
  6: Split parameters on grammar types with class constraints, e.g. IntExprType t => blah
       (recover type safety with modularity)
* CL option: --expr=typ (default is doc)
* pure :: a -> Bool (randomness or side-effect free)
* verifyType :: a -> Either SomeErr Bool?
* numRows and numCols need type argument
